package com.liyaqa.membership.domain.model

import com.liyaqa.shared.domain.BaseEntity
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.Table
import org.hibernate.annotations.Filter
import org.hibernate.annotations.FilterDef
import org.hibernate.annotations.JdbcTypeCode
import org.hibernate.annotations.ParamDef
import org.hibernate.type.SqlTypes
import java.time.Instant
import java.time.LocalDate
import java.time.LocalTime
import java.util.UUID

@Entity
@Table(name = "member_tasks")
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
class MemberTask(
    id: UUID = UUID.randomUUID(),

    @Column(name = "member_id", nullable = false)
    val memberId: UUID,

    @Enumerated(EnumType.STRING)
    @Column(name = "task_type", nullable = false)
    val taskType: TaskType,

    @Column(name = "title", nullable = false)
    var title: String,

    @Column(name = "description", columnDefinition = "TEXT")
    var description: String? = null,

    @Column(name = "due_date")
    var dueDate: LocalDate? = null,

    @Column(name = "due_time")
    var dueTime: LocalTime? = null,

    @Enumerated(EnumType.STRING)
    @Column(name = "priority", nullable = false)
    var priority: TaskPriority = TaskPriority.MEDIUM,

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    var status: TaskStatus = TaskStatus.PENDING,

    @Column(name = "assigned_to_user_id")
    var assignedToUserId: UUID? = null,

    @Column(name = "completed_at")
    var completedAt: Instant? = null,

    @Column(name = "completed_by_user_id")
    var completedByUserId: UUID? = null,

    @Enumerated(EnumType.STRING)
    @Column(name = "outcome")
    var outcome: TaskOutcome? = null,

    @Column(name = "outcome_notes", columnDefinition = "TEXT")
    var outcomeNotes: String? = null,

    @Column(name = "reminder_sent", nullable = false)
    var reminderSent: Boolean = false,

    @Column(name = "auto_generated", nullable = false)
    val autoGenerated: Boolean = false,

    @Column(name = "source")
    val source: String? = null,

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "metadata", columnDefinition = "jsonb")
    var metadata: Map<String, Any>? = null

) : BaseEntity(id) {

    /**
     * Assigns the task to a staff member.
     */
    fun assignTo(userId: UUID) {
        this.assignedToUserId = userId
    }

    /**
     * Unassigns the task.
     */
    fun unassign() {
        this.assignedToUserId = null
    }

    /**
     * Starts working on the task.
     */
    fun start() {
        require(status == TaskStatus.PENDING || status == TaskStatus.SNOOZED) {
            "Can only start tasks that are pending or snoozed"
        }
        status = TaskStatus.IN_PROGRESS
    }

    /**
     * Completes the task with an outcome.
     */
    fun complete(outcome: TaskOutcome, notes: String? = null, completedByUserId: UUID? = null) {
        require(status != TaskStatus.COMPLETED && status != TaskStatus.CANCELLED) {
            "Cannot complete a task that is already completed or cancelled"
        }
        this.status = TaskStatus.COMPLETED
        this.outcome = outcome
        this.outcomeNotes = notes
        this.completedAt = Instant.now()
        this.completedByUserId = completedByUserId
    }

    /**
     * Cancels the task.
     */
    fun cancel(reason: String? = null) {
        require(status != TaskStatus.COMPLETED && status != TaskStatus.CANCELLED) {
            "Cannot cancel a task that is already completed or cancelled"
        }
        this.status = TaskStatus.CANCELLED
        this.outcomeNotes = reason
    }

    /**
     * Snoozes the task until a new date.
     */
    fun snooze(newDueDate: LocalDate) {
        require(status == TaskStatus.PENDING || status == TaskStatus.IN_PROGRESS) {
            "Can only snooze pending or in-progress tasks"
        }
        this.status = TaskStatus.SNOOZED
        this.dueDate = newDueDate
    }

    /**
     * Reschedules the task.
     */
    fun reschedule(newDueDate: LocalDate, newDueTime: LocalTime? = null) {
        this.dueDate = newDueDate
        this.dueTime = newDueTime
        if (status == TaskStatus.SNOOZED) {
            status = TaskStatus.PENDING
        }
    }

    /**
     * Checks if the task is overdue.
     */
    fun isOverdue(): Boolean {
        if (status == TaskStatus.COMPLETED || status == TaskStatus.CANCELLED) return false
        val due = dueDate ?: return false
        return LocalDate.now().isAfter(due)
    }

    /**
     * Checks if the task is due today.
     */
    fun isDueToday(): Boolean {
        val due = dueDate ?: return false
        return LocalDate.now() == due
    }

    companion object {
        /**
         * Creates an onboarding check-in task.
         */
        fun onboardingCheckIn(
            memberId: UUID,
            memberName: String,
            dayNumber: Int,
            dueDate: LocalDate
        ): MemberTask = MemberTask(
            memberId = memberId,
            taskType = TaskType.ONBOARDING_CALL,
            title = "Day $dayNumber check-in call for $memberName",
            description = "Call new member to check on their onboarding progress and answer questions.",
            dueDate = dueDate,
            priority = TaskPriority.MEDIUM,
            autoGenerated = true,
            source = "ONBOARDING"
        )

        /**
         * Creates a renewal follow-up task.
         */
        fun renewalFollowUp(
            memberId: UUID,
            memberName: String,
            expiryDate: LocalDate,
            daysUntilExpiry: Long
        ): MemberTask = MemberTask(
            memberId = memberId,
            taskType = TaskType.RENEWAL_FOLLOWUP,
            title = "Renewal follow-up for $memberName",
            description = "Member's subscription expires on $expiryDate ($daysUntilExpiry days). Contact to discuss renewal.",
            dueDate = LocalDate.now(),
            priority = if (daysUntilExpiry <= 7) TaskPriority.HIGH else TaskPriority.MEDIUM,
            autoGenerated = true,
            source = "EXPIRY_REMINDER"
        )

        /**
         * Creates a retention outreach task.
         */
        fun retentionOutreach(
            memberId: UUID,
            memberName: String,
            riskLevel: String,
            riskReasons: List<String>
        ): MemberTask = MemberTask(
            memberId = memberId,
            taskType = TaskType.RETENTION_OUTREACH,
            title = "Retention outreach for $memberName ($riskLevel risk)",
            description = "Member is at risk of churning. Reasons: ${riskReasons.joinToString(", ")}",
            dueDate = LocalDate.now(),
            priority = if (riskLevel == "CRITICAL") TaskPriority.URGENT else TaskPriority.HIGH,
            autoGenerated = true,
            source = "CHURN_RISK"
        )

        /**
         * Creates a payment collection task.
         */
        fun paymentCollection(
            memberId: UUID,
            memberName: String,
            amountDue: String
        ): MemberTask = MemberTask(
            memberId = memberId,
            taskType = TaskType.PAYMENT_COLLECTION,
            title = "Collect payment from $memberName",
            description = "Outstanding amount: $amountDue. Contact to arrange payment.",
            dueDate = LocalDate.now(),
            priority = TaskPriority.HIGH,
            autoGenerated = true,
            source = "PAYMENT_FAILURE"
        )
    }
}

enum class TaskType {
    ONBOARDING_CALL,
    RENEWAL_FOLLOWUP,
    PAYMENT_COLLECTION,
    RETENTION_OUTREACH,
    WIN_BACK,
    GENERAL_FOLLOWUP,
    TOUR_SCHEDULED,
    TRIAL_FOLLOWUP,
    FEEDBACK_CALL,
    UPSELL_OPPORTUNITY
}

enum class TaskPriority {
    LOW,
    MEDIUM,
    HIGH,
    URGENT
}

enum class TaskStatus {
    PENDING,
    IN_PROGRESS,
    COMPLETED,
    CANCELLED,
    SNOOZED
}

enum class TaskOutcome {
    SUCCESSFUL,
    UNSUCCESSFUL,
    NO_ANSWER,
    RESCHEDULED,
    CANCELLED,
    LEFT_MESSAGE,
    MEMBER_DECLINED,
    MEMBER_CONVERTED
}
